package json
	export string, parse;
	
	import data, text;
	
	def unexpected(c) = Error("unexpected character: " + c);
	def badType(t) = Error("bad type: " + t.name);
	def unknown(id) = Error("unknown identifier: " + id);
	
	// TS --> JSON

	def jsonifiers = {
		Nil: fn(x) = "null",
		String: fn(x) = x.quote(),
		Boolean: fn(x) = x.toString(),
		Number: fn(x) = x.toString(),
		Array: fn(x) = "[" + x.map(string).join(",") + "]",
		Hash: fn(x) = "{" +
	        x.keys()
	         .map(fn(k) = k.quote() + ":" + string(x[k]))
	         .join(",") +
		"}",
		Function: fn(x) = throw(badType(x.type)),
		Class: fn(x) = throw(badType(x.type))
	};
	
	def toJson = Accessor("toJson");
	
	def string(x)
		if toJson.defined(x) then
			return x.toJson();
		end;
		def f = jsonifiers[x.type];
		if f then
			return f(x);
		end;
		
		def build(a) = a.name.quote() + ":" + string(a.get(x));
		def res = "{" +
			x.type.names("")
			      .map(Accessor)
			      .filter(fn(a) = a.property(x))
			      .map(build)
			      .join(",") +
		"}";
		if res == "{}" then
			throw(badType());
		end;
		return res;
	end;
	
	// JSON --> TS
	
	def digits = "0123456789", ws = " \n\t", over = ws + ",]}";
	
	def readChar(s) = text.utf8.read(s);
	
	def skipSpace(c, s)
		if ws.contains(c) then
			return skipSpace(readChar(s), s);
		end;
		return c;
	end;

	def expect(c, d)
		if c != d then
			throw(unexpected(c));
		end;
	end;
	
	def readNum(c, s, r, k)
		if c == "-" then
			return readInNum(readChar(s), s, r+c, k);
		end;
		return readInNum(c, s, r, k);
	end;
	
	def readInNum(c, s, r, k)
		def f;
		if digits.contains(c) then
			f = readInNum;
		elif c == "." then
			f = readFrac;
		elif "eE".contains(c) then
			f = readExp;
		else
			return k(c, r.toInt());
		end;
		return f(readChar(s), s, r+c, k);
	end;
	
	def readFrac(c, s, r, k)
		def f;
		if digits.contains(c) then
			f = readFrac;
		elif "eE".contains(c) then
			f = readExp;
		else
			return k(c, r.toFloat());
		end;
		return f(readChar(s), s, r+c, k);
	end;
	
	def readExp(c, s, r, k)
		if "+-".contains(c) then
			r = r + c;
			c = readChar(s);
		end;
		return readInExp(c, s, r, k);
	end;
		
	def readInExp(c, s, r, k)
		def f;
		if digits.contains(c) then
			f = readExp;
		else
			return k(c, r.toFloat());
		end;
		return f(readChar(s), s, r+c, k);
	end;
	
	def readStr(c, s, r, k)
		expect(c, "\"");
		r = r + c;
		return readInStr(readChar(s), s, r, k);
	end;
	
	def readInStr(c, s, r, k)
		r = r + c;
		if c == "\"" then
			return k(readChar(s), r.unquote());
		elif c == "\\" then
			r = r + readChar(s);
		end;
		return readInStr(readChar(s), s, r, k);
	end;
	
	def readArr(c, s, r, k)
		expect(c, "[");
		return readInArr(readChar(s), s, [], k);
	end;
	
	def readInArr(c, s, r, k)
		c = skipSpace(c, s);
		if c == "]" then
			return k(readChar(s), r);
		end;
		return dispatch(c, s, fn(c, ret)
			expect(skipSpace(c, s), ",");
			r.add(ret);
			return readInArr(readChar(s), s, r, k);
		end);
	end;
	
	def readDict(c, s, r, k)
		expect(c, "{");
		return readInDict(readChar(s), s, {}, k);
	end;
	
	def readInDict(c, s, r, k)
		c = skipSpace(c, s);
		if c == "}" then
			return k(readChar(s), r);
		end;
		return readStr(c, s, "", fn(c, name)
			expect(skipSpace(c, s), ":");
			c = skipSpace(readChar(s), s);
			return dispatch(c, s, fn(c, val)
				expect(skipSpace(c, s), ",");
				r[name] = val;
				return readInDict(readChar(s), s, r, k);
			end);
		end);
	end;
	
	def readBuiltin(name, val)
		def next(c, s, r, k)
			if over.contains(c) then
				if r != name then
					throw(unknown(r));
				end;
				return k(c, val);
			end;
			return next(readChar(s), s, r+c, k);
		end;
		return next;
	end;
	
	def lexers = {
		"\"": readStr,
		"[": readArr,
		"{": readDict,
		"t": readBuiltin("true", true),
		"f": readBuiltin("false", false),
		"n": readBuiltin("null", nil),
		"-": readNum
	};
	digits.split().each(fn(c)
		lexers[c] = readNum;
	end);
	
	def dispatch(c, s, k)
		def p = lexers[c];
		if !p then
			throw(unexpected(c));
		end;
		return p(c, s, "", k);
	end;
	
	def parse(s) = dispatch(readChar(s), s, fn(c, r) = r);
	
end;


