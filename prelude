// The part of the standard library implemented in TranScript.

// Iteration
// =========
//
// An iterable supports one method: __iter__() that returns an iterator.
//
// An iterator supports two methods: __iter__() that returns itself and next()
// that moves the iterator onwards, returning the next item, or done if there
// are no more items.

// Call a function for every item in an iterable. That function may return done,
// so halting iteration.
def for(it, f)
	it = it.__iter__();
	def step()
		def x = it.next();
		if x != done then
			if f(x) != done then
				return step();
			end;
		end;
	end;
	return step();
end;

// Turn a function into an iterator.
class FnIterator(Iterator)
	def create(f)
		this.f = f;
	end;
	def next() = this.f();
	def copy() = this;
private
	def f;
end;

// Create an iterator composed of the return values of applying a function to
// each item in a source iterable.
def map(it, f)
	it = it.__iter__();
	return FnIterator(fn()
		def x = it.next();
		if x != done then
			return f(x);
		end;
		return done;
	end);
end;

def reduce(it, acc, f)
	for(it, fn(x)
		acc = f(x, acc);
	end);
	return acc;
end;

// Create an iterator composed of all the items in an iterable that pass a
// criterion function.
def filter(it, f)
	it = it.__iter__();
	def check()
		def x = it.next();
		if x == done then
			return done;
		end;
		if f(x) then
			return x;
		end;
		return check();
	end;
	return FnIterator(fn()
		return check();
	end);
end;

// Find the first item in an iterable that passes a criterion function, or false
// if no items match.
def find(it, f)
	def res = filter(it, f).next();
	if res == done then
		return false;
	end;
	return res;
end;

// Create an iterator composed of a series of iterables. When one iterator
// signals it is at an end by returning done, the next iterable is used. When no
// more iterables remain, append returns done.
def append(it, rest*)
	it = it.__iter__();
	def next()
		def x = it.next();
		if x == done then
			if rest.size == 0 then
				return done;
			end;
			it = rest[0].__iter__();
			rest = rest.slice(1);
			return next();
		end;
		return x;
	end;
	return FnIterator(fn()
		return next();
	end);
end;

// Turn an iterator into an array.
def slurp(it)
	def res = [];
	for(it, fn(x) = res.add(x));
	return res;
end;

// Rearrange arrays so that rows become columns.
def zip(as*)
	def alen = as.size, rlen = 1/0;
	as.each(fn(x)
		def s = x.size;
		if s < rlen then
			rlen = s;
		end;
	end);
	if rlen == 1/0 then
		throw(Error("infinite range"));
	end;
	def res = Array(rlen);
	for(Range(rlen), fn(i)
		def a = Array(alen);
		for(Range(alen), fn(j)
			a[j] = as[j][i];
		end);
		res[i] = a;
	end);
	return res;
end;

// Represent a range of numbers as if it were an array.
class Range()
	def create(from, to?)
		this.from = (to && from) || 0;
		this.to = to || from;
	end;
	def size get()
		if this.to then
			return this.to - this.from;
		end;
		return 1/0;
	end;
	def __aget__(off)
		if off > this.size then
			throw(Error("index out of range"));
		end;
		return this.from + off;
	end;
	def __iter__()
		def cur = this.from, to = this.to;
		return FnIterator(fn()
			if cur < to then
				cur = cur + 1;
				return cur - 1;
			end;
			return done;
		end);
	end;
private
	def from, to;
end;

// Printf-like function.
def printf(pat, xs*)
	print(pat.subst.apply(xs));
end;

// Collects functions to multiplex calls over.
class Event()
	def create()
		this.handlers = [];
	end;
	// Add a handler: this is a function that will get called whenever the 
	// event is called.
	def add(h)
		this.handlers.add(h);
	end;
	// Remove a handler.
	def remove(h)
		this.handlers.remove(h);
	end;
	// Allows the event object to have a function call interface.
	def __call__(args*)
		this.handlers.each(fn(h) = h.apply(args));
	end;
private
	def handlers;
end;

// Schedule some code to run whether an error happened or not.
def finally(thk, clearup)
	def e = catch(thk);
	def f = catch(clearup);
	if e then
		throw(e);
	end;
	if f then
		throw(f);
	end;
end;

// Register a function to be called if an error is raised during the execution
// of a thunk.
def split(thk, h)
	def res;
	def e = catch(fn()
		res = thk();
	end);
	if e then
		return h(e);
	end;
	return res;
end;

def switchType(x, cs*)
	for(cs, fn(c)
		if x.is(c[0]) then
			c[1]();
			return done;
		end;
	end);
end;

// Call a function with an escape (one-shot) continuation.
//
// Calls f, and whatever it returns is returned by callWithCont(). f takes a
// single parameter, a continuation object.
//
// The continuation object is a function that takes a single argument. When
// called, it causes callWithCont() to return the value of that argument.
//
// This is somewhat like call/cc in Scheme. However, unlike Scheme's
// continuations, these continuations are not valid after callWithCont()
// returns.
def callWithCont(f)
	def key = Object(),
	    followed = false,
	    res;
	def e = catch(fn()
		res = f(fn(x)
			if followed then
				throw("stale continuation");
			end;
			throw([key, x]);
		end);
	end);
	followed = true;
	// normal return
	if !e then
		return res;
	end;
	// followed continuation
	if e.is(Array) && e.size == 2 && e[0] == key then
		return e[1];
	end;
	// error
	throw(e);
end;

class Package()
end;

def packages = class()
	def packagePaths = ["/usr/local/go/src/pkg/github.com/bobappleyard/ts"];
	def create()
		def root = loadExtension("system").env["TSROOT"];
		if root then
			this.packagePaths = [root + "/pkg"];
		end;
	end;
	def __aget__(nm)
		def p = this.pkgs[nm];
		if p then
			return p;
		end;
		def nmpath = nm.replace(".", "/") + ".pkg";
		for(this.packagePaths, fn(path)
			path = path + "/" + nmpath;
			if catch(fn() = load(path)) then
				return;
			end;
			p = this.pkgs[nm];
			if p then
				return done;
			end;
		end);
		if !p then
			throw("undefined package: " + nm);
		end;
		return p;
	end;
	def __aset__(nm, p)
		this.pkgs[nm] = p;
	end;
private
	def pkgs = {};
end();


