// The part of the standard library implemented in TranScript.

// Basic iterative constructs.

def loop(f)
	f();
	return loop(f);
end;

def while(f)
	if f() then
		return while(f);
	end;
end;

def for(from, to, f)
	if from < to then
		if !f(from) then
			return;
		end;
		return for(from + 1, to, f);
	end;
end;

// Rearrange arrays so that rows become columns.
def zip(as*)
	def alen = as.size, rlen = 1/0;
	as.each(fn(x)
		def s = x.size;
		if s < rlen then
			rlen = s;
		end;
	end);
	if rlen == 1/0 then
		throw(Error("infinite range"));
	end;
	def res = Array(rlen);
	for(0, rlen, fn(i)
		def a = Array(alen);
		for(0, alen, fn(j)
			a[j] = as[j][i];
		end);
		res[i] = a;
	end);
	return res;
end;

// Map like in Scheme.
def map(f, ls*)
	return zip.apply(ls).map(f.apply);
end;

// Represent a range of numbers as if it were an array.
class Range()
	def create(from, to?)
		this.from = from;
		this.to = to;
	end;
	def size get()
		if this.to then
			return this.to - this.from;
		end;
		return 1/0;
	end;
	def __aget__(off)
		if off > this.size then
			throw(Error("index out of range"));
		end;
		return this.from + off;
	end;
private
	def from, to;
end;

// Printf-like function.
def printf(pat, xs*)
	print(pat.subst.apply(xs));
end;

// Collects functions to multiplex calls over.
class Event()
	def create()
		this.handlers = [];
	end;
	// Add a handler: this is a function that will get called whenever the 
	// event is called.
	def add(h)
		this.handlers.add(h);
	end;
	// Remove a handler.
	def remove(h)
		this.handlers.remove(h);
	end;
	// Allows the event object to have a function call interface.
	def __call__(args*)
		this.handlers.each(fn(h) = h.apply(args));
	end;
private
	def handlers;
end;

// Schedule some code to run whether an error happened or not.
def finally(thk, clearup)
	def e = catch(thk);
	def f = catch(clearup);
	if e then
		throw(e);
	end;
	if f then
		throw(f);
	end;
end;

// Register a function to be called if an error is raised during the execution
// of a thunk.
def split(thk, h)
	def res;
	def e = catch(fn()
		res = thk();
	end);
	if e then
		return h(e);
	end;
	return res;
end;

// Call a function with an escape (one-shot) continuation.
//
// Calls f, and whatever it returns is returned by callWithCont(). f takes a
// single parameter, a continuation object.
//
// The continuation object is a function that takes a single argument. When
// called, it causes callWithCont() to return the value of that argument.
//
// This is somewhat like call/cc in Scheme. However, unlike Scheme's
// continuations, these continuations are not valid after callWithCont()
// returns.
def callWithCont(f)
	def key = Object(),
	    followed = false,
	    res;
	def e = catch(fn()
		res = f(fn(x)
			if followed then
				throw("stale continuation");
			end;
			throw([key, x]);
		end);
	end);
	followed = true;
	// normal return
	if !e then
		return res;
	end;
	// followed continuation
	if e.is(Array) && e.size == 2 && e[0] == key then
		return e[1];
	end;
	// error
	throw(e);
end;

